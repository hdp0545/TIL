# 스프링 부트 퀵 스타트

### 1. 스프링 프레임 워크

- 프레임워크는 어플리케이션의 아키텍처에 해당한다.

- POJO 기반의 경량 환경을 제공

- 다른 프레임워크와의 통합을 지향
  
  -> 결국 복잡해짐

### 2. 스프링 부트의 등장

- 스프링 부트의 장점
  
  - 라이브러리 관리 자동화
  
  - 라이브러리 의존성 문제를 해결한다.(Starter)
  
  - 설정의 자동화(Auto configuration)
    
    - `@configuration`어노테이션을 통해 자동으로 메모리에 올라와 있음
  
  - 테스트환경(Test Driven Development)
    
    - 내장서버를 갖추고 있음
  
  - 독립 실행가능한 JAR(JEUS 등 서버 배포에서 쉬움)

### 3. 환경설정

- 스프링부트 버전 3점대를 사용해야 스프링 6버전을 쓸 수 있다.

- Spring Boot DevTools
  
  - 소스가 변경될 때마다, 자동적으로 변경사항을 적용한다.
  
  - Web application 상태에서만 소스변경을 인식 할 수 있다.

- Lombok
  
  - DTO, VO 파일 생성할 때, 자동으로 getter setter 코드를 작성해준다.

- Spring Web
  
  - Spring 을 웹으로 실행하기 위한 라이브러리의 묶음(starter라고 함)
  
  - tomcat등 웹 어플리케이션 실행을 위한 기본 라이브러리 자동 다운로드

- Maven
  
  - 디펜던시를 관리함

- Alt + Shift + T
  
  - 인터페이스 설정을 통해 함수명의 다형성 관리를 해줄 수 있다.

- IOC (Inversion of control)
  
  - 역제어 객체의 생성 및 관리를 컨테이너에게 위임한 개발 형태
  
  - 자바소스에서 객체를 생성하는 것이 아닌 xml파일(컨테이너 설정파일)을 수정하여 객체생성 및 찾는 방식을 수정한다. 

- `@Bean("id")` 태그를 통해 클래스로 xml파일 수정없이 클래스처럼 bean 주입이 가능하다.
  
  - id이름을 입력하지 않으면 method 이름이 자동으로 id가 된다.
  
  - `AnnotationConfigApplicationContext container = new AnnotationConfigApplicationContext("context.xml");`

- 설정 클래스를 따로 지정하여 xml 을 수정하지 않는게 Spring Boot

- Bean injection
  
  - setter injection
  
  - Type injection
  
  - 주입함수 작성

- 환경설정 클래스가 없이도 메모리에 componet속성이 잇는 어노테이션을 붙이면 메모리 위에 띄울 수 있다.
  
  - 이 뜻은 xml 파일로 환결설정을 하던 Spring에서 어노테이션을 통해 환경설정 없이 띄워 사용할 수잇다.

- properties 설정이 자바 설정보다 우선순위가 높다.
  
  - properties 를 통해 spring의 기본설정들을 바꿀 수 있다.

- `src/main/resources/banner.txt`의 경로에서 배너 이미지를 수정할 수 있다.
  
  ### WebApplication 작성

- `@RestController` 
  
  - 위 코드가 적용된 컨트롤러는 모든 메소드 리턴 타입에 ResponseBody가 붙는다.

- `@GetMapping("url")`

- `@ResponseBody String`
  
  - 리턴되는 데이터가 자바 객체인 경우  JSON으로 변환하여 HTTP 응답 프로토콜 Body에 출력하고, 문자열일 경우 값자체를 리턴함

- `@SpringBootApplication`
  
  - `@SpringConfiguration`, `@EnableAutoConfiguration`, `@ComponentScan`로 이루어져 있다.
  
  - 만약 메모리에 다른 패키지에 있는 컨트롤러를 메모리에 띄우고 싶다면 컴포넌트 스캔에 베이스 컴포넌트를 재정의 해야한다.
    
    `@Component`를 상속하는 컴포넌트:
    
    `@Service`, `@Controller`, `@SpringBootApplication`
  
  - 이는 환경설정 클래스임을 의미한다.

- Lombok은 반드시 이클립스에 미리 설치해야한다.
  
  - Lombok은 getter setter작성을 편리하게 해주고 추후 유지보수시 멤버변수를 작성안해도 된다.

- ```java
  @Data
  //@Getter
  //@Setter
  //@ToString
  //@EqualsAndHashCode
  ```

### 스타터를 사용한 의존성 관리

- maven project 를 생성하여 다양한 라이브러리를 사용자정의 스타터를 통해 관리 가능하다.

- 특정 프로젝트에서 `<properties>`를 통해 상속받은 버전이 아닌 다른 버전으로 관리가 가능하다. 

- 스타터의 AutoConfiguration을 이용해서 객체를 자동으로 띄워주는것도 가능하다

- WebMvcAutoConfiguration
  
  ```java
      // web어플리케이션 설정이 서블릿으로 되어있고
    @ConditionalOnWebApplication(type = Type.SERVLET)
    // 클래스 패스 상에 밑의 클래스들이 존재하고
    @ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })
    // 밑의 객체가 없을 때, configuration 해준다.
    @ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
    // 우선순위 설정
    @AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
  ```
  
  - AutoConfigruation 을 통해 자동설정 클래스들을 로딩하고 ComponentScan을 통해 직접등록한 클래스들을 로딩한다.

- `\src\main\resources\META-INF\spring\org.springframework.boot.autoconfigure.AutoConfiguration.imports` 자동설정 경로

- `conditional`조건이 붙지 않은 자동설정 클래스는 언컨디셔널 클래스 쪽에 저장되며
  
  이는 무조건 실행된다.

- SprinBootAplication은  `@componentScan` 이 먼저 적용되기 때문에 AutoConfiguration을 재정의가 불가능하다. 이를 가능하게 하려면 다음과 같은 방법이 필요하다.
  
  - AutoConfiguration 파일에 `@ConditionalOnMissingBean`조건을 넣어준다. 위 조건을 통해 개인적인 설정을 하지 않은 경우에만 AutoConfiguration을 적용하게 할 수 있다.
  
  - property 이용하기
    
    객체를 재정의하여 다시 생성하는 것이 오래걸리는 경우, 멤버변수 값만을 바꿔서 설정할 수 있다.
    
    하드코딩이 아닌 properties를 생성하고 이를 참조해서 AutoConfiguration하게 할 수 있다.
    
    - `@ConfigurationProperties(prefix = "board.jdbc")`
      
      AutoConfiguration 클래스의 프로퍼티임을 나타내는 어노테이션
      
      접두사를 통해 실제 어플리케이션의 프로퍼티에서 이 값을 설정할 수 있다.
    
    - `@EnableConfigurationProperties(ConnectionManagerProperties.class)`
      
      ConfigurationProperties가 붙어있는 클래스 로딩 

### DB 연결

- 데이터소스객체가 뜨긴 하나 어플리케이션 메모리에서 DB를 찾으므로 프로퍼티 설정이 필요하다.
  
  1. ```java
     //    @Bean
     //    DataSource dataSource() {
     //        HikariDataSource dataSource = new HikariDataSource();
     //        dataSource.setDriverClassName("org.h2.Driver");
     //        dataSource.setJdbcUrl("jdbc:h2:tcp://localhost/~/test");
     //        dataSource.setUsername("sa");
     //        dataSource.setPassword("");
     //        return dataSource;
     //    }
     ```
  
  2. ```xml
     # DataSource Setting
     spring.datasource.hikari.driver-class-name=org.h2.Driver
     spring.datasource.hikari.jdbc-url=jdbc:h2:tcp://localhost/~/test
     spring.datasource.hikari.username=sa
     spring.datasource.hikari.password=
     ```

# 3. 테스트

### JUnit

- 컨트롤러를 테스트하기 위해서는 우선 서블릿 컨테이너(TOMCAT)가 구동되어야 하고 브라우저를 통해 요청/응답 결고를 확인해야하기 때문에 복잡함

- 서버구동없이 테스트 할 수 있는 환경 구축 JUNIT3
  
  ```
  ===> MyCalcTest 생성
  ---> setup()
  ---> testplus()
  ---> tearDown()
  ```
  
  자동으로 set up, tearDown 함수까지 실행해준다.

- JUNIT4
  
  - 메소드 이름을 마음대로 할 수 있음(어노테이션 달아줘야함)
  
  ```java
  public class MyCalcTest {
  
      private MyCalc calc;
  
      @BeforeClass
      public static void setUpBeforeClass() throws Exception {
      }
  
      @AfterClass
      public static void tearDownAfterClass() throws Exception {
      }
  
      @Before
      public void setUp() throws Exception {
          System.out.println("---> setup()");
          calc = new MyCalc(10, 3);
      }
  
      @After
      public void tearDown() throws Exception {
          System.out.println("---> tearDown()");
          calc = null;
      }
  
      @Test
      public void testPlus() {
          System.out.println("---> testplus()");
          assertEquals(13, calc.plus());
      }
  
      @Test
      public void testMinus() {
          System.out.println("---> testMinus()");
          assertEquals(7, calc.minus());
      }
  
  }
  ```

- SpringBoot Test
  
  ```java
  @SpringBootTest(properties = {"author.name=gugu", "author.age=28", "author.nation=KOREA"}, 
                  classes = BoardDAO.class)
  class PropertiesTest {
  
      //외부 프로퍼티 추출
  //    @Value("${author.name}")
  //    private String name;
  //    
  //    @Value("${author.age}")
  //    private int age;
  
      @Autowired
      private Environment env;
  
      @Test
      void testMethod() {
  //        assertTrue(true);
          System.out.println("이름 : " + env.getProperty("author.name"));
          System.out.println("나이 : " + env.getProperty("author.age"));
          System.out.println("국가 : " + env.getProperty("author.nation"));
      }
  ```
  
  외부 프로퍼티를 추출해서 사용하거나 SpringBootTest의 properties 인자를 통해 정의해서 사용할 수 있다.
  
  또한 클래스를 명시하여 로딩할 클래스를 제한 할 수 있다.

##### Mock MVC

- 목(Mock)의 사전적 의미는 *테스트를 위해 만든 모형* 이다.

- Mocking : 실제 서블릿을 이용해서 목을 만드는것

- mock up : 목킹한 객체를 메모리에 띄우는 것

- 서블릿 컨테이너를 목킹하면 테스트용 모의 컨테이너를 사용한다. 실제 서블릿 컨테이너 없이도 컨트롤러 테스트가 가능하다.

- 서블릿 컨테이너를 모킹하기 위해서는 `@WebMvcTest` , `@AutoConfiguremockMvc`를 사용한다.
  
  - `@WebMvcTest`
    
    - 서블릿 컨테이너를 목킹하여 가벼운 가짜 컨테이너를 생성. 
    
    - 컨트롤러만을 메모리에 로딩함(주로 이걸 사용함)
    
    - Tomcat을 거치지 않고 Mockmvc(컨테이너) 에게 직접 요청하여 빠른 응답을 받음.
    
    ```java
    @WebMvcTest
    class BoardControllerTest {
    
        @Autowired
        private MockMvc mockMvc;
    
        @Test
        void testHello() throws Exception {
            // HTTP 요청 (http://localhost:8080/hello?name=gugu) 을 전송한다.
            mockMvc.perform(MockMvcRequestBuilders.get("/hello").param("name", "gugu"))
    
            //  가짜 서블릿 컨테이너가 리턴한 HTTP 응답결과를 검증한다.
            .andExpect(MockMvcResultMatchers.status().isOk())
            .andExpect(MockMvcResultMatchers.content().string("hello : gugu"));
        }
    }
    ```
  
  - `@AutoConfigureMockMvc`
    
    - 서비스, DAO 다 로딩함

- Tomcat 서버 사용해서 테스트하기
  
  - 웹브라우저를 모킹하는 `TestRestTemplate` 를 사용함
  
  ```java
  @SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT    )
  class BoardControllerTest2 {
  
      @Autowired
      //TestRestTemplate 객체는 웹 브라우저를 모킹한 객체이다.
      private TestRestTemplate restTemplate;
  
      @Test
      void testHello() throws Exception {
          String result = restTemplate.getForObject("/hello?name=gugu", String.class);
          assertEquals("hello : gugu", result);
      }
  }
  ```

- 서비스 부가 개발되어 있지 않을 때, 인터페이스만을 생성하여 컨트롤러를 테스트 할 수 있다. 
  
  - `@MockBean`을 이용하여 비즈니스 객체 자체를 목킹하여 테스트 할 수 있다.
  
  ```java
  @SpringBootTest(webEnvironment = WebEnvironment.MOCK) // Tomcat 을 구동하지 않는다.
  @AutoConfigureMockMvc
  class BoardControllerTest3 {
  
      @Autowired
      private MockMvc mockMvc; //목킹된 객체를 목업한다.
  
      @MockBean //MockBean이 설정된 변수에 BoardService 타입의 Mock 객체를 할당한다.
      private BoardService boardService;
  
      @Test
      void testHello() throws Exception {
          // 모킹된 비즈니스 객체의 메소드를 호출했을 때, 리턴될 결과값을 설정한다.
          when(boardService.hello("gugu")).thenReturn("hello : gugu");
  ```
  
          // HTTP 요청 (http://localhost:8080/hello?name=gugu) 을 전송한다.
          mockMvc.perform(MockMvcRequestBuilders.get("/hello").param("name", "gugu"))
      
          //  가짜 서블릿 컨테이너가 리턴한 HTTP 응답결과를 검증한다.
          .andExpect(MockMvcResultMatchers.status().isOk())
          .andExpect(MockMvcResultMatchers.status().is(200))
          .andExpect(MockMvcResultMatchers.content().string("hello : gugu"));
      }
  
  }

```
### 스프링부트 로깅

- SLF4J는 로깅프레임워크가 아닌 퍼사드다. 

- SLF4J 퍼사드를 통해 LogBack이라는 로그프레임워크를 사용한다.

- 퍼사드를 이용하면 로그 프레임워크와의 의존성이 낮아지기 때문에 로그프레임워크를 쉽게 교체할 수 있다.

- properties를 수정하여 간단한 로그 설정을 변경할 수 있다.

```properties
#로그 설정

logging.level.com.rubypaper=debug
logging.file.name=C:/DEV/board_log.logg

# 로그 패턴 변경
logging.pattern.console=%d{yyyy:MM:dd HH:mm:ss.SSS} %-5level --- [%thread] %logger{35} : %msg %n
```

- 다양한 로그 설정이 하고 싶으면 logback.xml 파일에서 수정하여야 한다.

##### JAR 패키징

- Maven 빌드를 통해 JAR 패키지를 만들 수 있다.

- 기본 세팅 clean package

### Mybatis연동

- dataSource 가 뜨고 mybatis 컨테이너가 뜨면서 어노테이션을 사용해 사용한다.

# 4. JPA 연동

- ORM 프레임 워크는 DB 연동 기능코드 뿐만 아니라 SQL까지 제공한다.

- 영속성유닛이란?
  
  - JPA를 이용하여 데이터베이스를 사용하려면 Entitymanager를 생성해야한다.
  
  - EntityManager는 EntityManagerFactory에서 획득한다.
  
  - EntityManagerFactory는 Persistence 객체가 생성하고 이는 persistence.xml을 로딩하여 설정된다.

- Persistence 설정부
  
  - Entity 클래스 표기
  
  - DB연결 설정 표기
  
  - Hibernate 설정
    
    -  dialect 설정 (사용할 DB를 설정한다.)
    
    - show_sql
    
    - format_sql
    
    - hbm2ddl.auto 설정

- persistence.xml 예시

```xml
<persistence version="2.1"    xmlns="http://xmlns.jcp.org/xml/ns/persistence" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://xmlns.jcp.org/xml/ns/persistence http://xmlns.jcp.org/xml/ns/persistence/persistence_2_1.xsd">
    <persistence-unit name="Chapter04">
        <class>com.rubypaper.domain.Board</class>
        <properties>
            <property name="javax.persistence.jdbc.driver" value="org.h2.Driver"/>
            <property name="javax.persistence.jdbc.url" value="jdbc:h2:tcp://localhost/~/test"/>
            <property name="javax.persistence.jdbc.user" value="sa"/>
            <property name="javax.persistence.jdbc.password" value=""/>

            <!-- JPA 구현체(default : Hibernate) 설정 -->
            <property name="hibernate.dialect" value="org.hibernate.dialect.H2Dialect"/>
            <property name="hibernate.show_sql" value="true"/>
            <property name="hibernate.format_sql" value="true"/>
            <property name="hibernate.hbm2ddl.auto" value="update"/>

        </properties>
    </persistence-unit>
</persistence>
```

- Entity설정

- ```java
  @Data
  @Entity
  //@TableGenerator(name="BOARD_SEQ_GENERATOR", table="SEQUENCE_TABLE", pkColumnName="BOARD_SEQ", initialValue=0, allocationSize=1)
  @SequenceGenerator(name="BOARD_SEQ_GENERATOR", sequenceName="BOARD_SEQUENCE", initialValue=1, allocationSize=1)
  @Table(name="MY_BOARD")
  public class Board {
      @Id // 필수 (식별자 변수를 매핑한다. PK와 매핑되는 변수)
      @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "BOARD_SEQ_GENERATOR")//(strategy = GenerationType.TABLE, generator = "BOARD_SEQ_GENERATOR") // (테이블 생성 어노테이션)
      private int seq;
      private String title;
  
      @Column(updatable=false, unique = true,  nullable = false)
      private String writer;
      private String content;
  
      @Column(name = "REG_DATE", nullable = false)
      private Date regDate;
  
      @Column(insertable = false)
      private int cnt;
  }vate int cnt;
  }
  ```

- 

- 구현 소스

```java
@Override
    public void run(ApplicationArguments args) throws Exception {
        // EntityManagerFactory 생성
        EntityManagerFactory emf = Persistence.createEntityManagerFactory("Chapter04");
        // EntityManager 생성
        EntityManager em = emf.createEntityManager();

        // 상세 조회
        Board board1 = em.find(Board.class, 1);
        System.out.println("검색된 게시글 : " + board1.toString());

        // 목록검색
        String jpql = "select b from Board b order by b.seq desc";
        List<Board> boardList= em.createQuery(jpql).getResultList();
        for (Board board : boardList) {
            System.out.println("---> " + board.toString());
        }

        em.close();
        emf.close();
    }
```

- jpql 은 sql 과 다르게 from 절 뒤에 오는 것은 테이블이 아닌 클래스 명이며 select 절 뒤에 오는 것은 변수명이다. (\*치지 않음)

- 업데이트시에는 따로 저장이 필요없다.

```java
        // 수정하기
        Board findBoard = em.find(Board.class, 1);
//        findBoard.setTitle("--- 제목 수정");
//        findBoard.setContent("--- 내용 수정");
```

- `@GeneratedValue` 어노테이션에 값을 선택하여 식별자 값 생성전략을 선택할 수 있다.

```java
@Data
@Entity
@TableGenerator(name="BOARD_SEQ_GENERATOR", table="SEQUENCE_TABLE", pkColumnName="BOARD_SEQ", initialValue=0, allocationSize=1)
public class Board {
    @Id // 필수 (식별자 변수를 매핑한다. PK와 매핑되는 변수)
    @GeneratedValue(strategy = GenerationType.TABLE, generator = "BOARD_SEQ_GENERATOR") // (시퀀스 생성 어노테이션)
    private int seq;
    private String title;
    private String writer;
    private String content;
    private Date regDate;
    private int cnt;
}
```

- 테이블 전략은 느리나 모든 DB에서 사용할 수 있다.

- AUTO 전략을 사용하면 DB에 맞는 전략을 사용할 수 있다.

##### 영속성 컨테이너의 엔티티 관리

영속성컨테이너(JPA의 엔티티와 DB를 동기화 해주는 컨테이너)가 관리하는 상태를 의미함

영속성 컨테이너는 commit 명령어를 받아 들여야 DDL SQL을 날림.

4가지 상태 외울것

- 비영속상태(NEW)
  
  - 영속성 컨테이너가 관리하고 있지 않는 엔티티

- 영속상태(MANAGED)
  
  - 영속성 컨테이너가 관리하는 상태
  
  - find(), persist(),merge()(준영속 -> 영속) 함수를 통해 영속상태가 된다.

- 준영속상태(DETACHED)
  
  - 준영속 상태는 영속 상태에서 벗어난 상태를 의미한다.
  
  - 준영속 상태의 엔티티는 수정하여도 DB에 영향을 끼치지 못한다.
  
  - detach(), clear(), close() 함수를 통해서 준영속상태가 된다.

- 삭제상태(REMOVED)
  
  - 영속상태에서 remove() 함수를 통해 삭제상태가 된다.

##### 엔티티수정과 스냅샷

- 엔티티를 컨테이너에 저장할 때 1차 캐시와 SQL 저장소에 엔티티와 SQL구문 들이 누적된다(스냅샷).

- 트랜잭션이 종료 될 때, 1차 캐시의 엔티티를 비교해서 Update 구문을 만든다.(더티체킹)

### 

### 5.스프링 데이터 JPA

- JPA연동을 자동으로 제공해주기 위해 스타터를 제공함

- CURD 작성법

```java
@SpringBootTest
class BoardRepositoryTest {
	
	@Autowired
	private BoardRepository boardRepository;
	
	@Test
	void testDeleteBoard() {
		boardRepository.deleteById(1);
	}
	
//	@Test
	void testUpdateBoard() {
		Board board = new Board();
		board.setSeq(1);
		board.setTitle("---수정제목");
		board.setContent("내용수정");
		boardRepository.save(board);
	}
	
//	@Test
	void testGetBoard() {	
		Optional<Board> findBoard = boardRepository.findById(1);
		if(findBoard.isPresent()) {
			Board board = findBoard.get();
		System.out.println(board.toString());
		}
	}
	
//	@Test
	void testInsertBoard() {
		Board board = new Board();
		board.setTitle("JPA Test");
		board.setWriter("테스터");
		board.setContent("JPA 등록테스트");
		boardRepository.save(board);
	}
}
```

- 쿼리메소드
  
  - 복잡한 JPQL을 메소드로 처리할 수 있도록 작성하는 메소드.
  
  - `find + 엔티티 이름(생략가능) + By + 변수이름`

- 연관관계 매핑
  
  - RDBMS와 유사하게 엔티티역시 참조 변수를 통해 연관된 데이터를 조회할 수 있다.
  
  - 하지만, 정확히 일치하지는 않는데 이를 패러다임의 불일치라 한다.
  
  - 고려사항
    
    - 방향 : 방향은 객체에만 존재한다.
    
    - 다중성
    
    - 연관관계 주인 : 객체를 양방향 연관관계로 매핑하려면 주인을 정해야한다. 일반적으로는 주인은 (N)쪽이 된다.
